0000              ; ------ Memory layout and hardware registers   -----------------------------
0000              
0000              DATA      = $0200
0000              CODE      = $0800
0000              XDATAPAGE = $0100
0000              XDATABANK = $0101
0000              PORT2     = $0102
0000              PORT3     = $0103
0000              
0000              ; -------- universally usable variables and call parameters -----------------
0000                  AREA DATA 8
0200 00           L0: BYTE 0
0201 00           L1: BYTE 0
0202 00           L2: BYTE 0
0203 00           L3: BYTE 0
0204 00           L4: BYTE 0
0205 00           L5: BYTE 0
0206 00           L6: BYTE 0
0207 00           L7: BYTE 0
0208              
0208              
0208              ; ------ Startup code to copy program from ROM to RAM and start it ----------
0208              
0208                  ; Very small bootstrap to be executed from ROM
0208                  ORG $0000
0000                  ; copy the second copy routine to RAM
0000 b1 80            SET R1 $80 ; source address in page 0
0002 7a               ZERO R2    ; target address in code page
0003 b3 08            SET R3 ^CODE ; target page
0005              BOOTSTRAPLOOP:
0005 a1               DP 0
0006 c4               LD R0 R1
0007 ac               DP R3
0008 d8               ST R0 R2
0009 b0 01            SET R0 1
000b 11               ADD R1 R0
000c 12               ADD R2 R0
000d 84 05            BGE R1 R0 BOOTSTRAPLOOP
000f b0 00 b1 08      GOTO COPYROUTINE2
0013 94          
0014              
0014                  ; second copy loop: this code is already executed from RAM so it can
0014                  ; switch ROM banks. It will initialize everything including its own program code,
0014                  ; but this does no harm as it is already in place
0014                  ORG CODE
0800              
0800              COPYROUTINE2:
0800                  ; before doing more copying init the output port registers
0800 b1 ff            SET R1 $FF
0802 a3 b0 02 d1      STORE R1 PORT2
0806 a3 b0 03 d1      STORE R1 PORT3
080a              
080a b3 02            SET R3 $02 ; loop counter: high byte of target address
080c              COPYLOOP2:
080c                  ; set up the extension memory page address
080c a3 b0 00 d3      STORE R3 XDATAPAGE
0810                  ; copy a whole page in one loop
0810 7a               ZERO R2   ; loop counter for low byte target address
0811              INNERLOOP2:
0811 a1               DP 0
0812 c9               LD R1 R2
0813 ac               DP R3
0814 d9               ST R1 R2
0815 b0 01            SET R0 1
0817 12               ADD R2 R0
0818 88 11            BGE R2 R0 INNERLOOP2
081a 13               ADD R3 R0
081b 8c 0c            BGE R3 R0 COPYLOOP2
081d              
081d                  ; start user program
081d b0 08 b1 0d      GOTO MAIN
0821 94          
0822              
0822              ; ------------------------------ Serial communication -----------------------
0822              
0822                  ; This subsystem implements a bit-banged UART communication.
0822                  ; Communication is done with 115200 baud using flow control with RTS/CTS.
0822                  ; With a 10MHz CPU clock, transmission of one serial bit takes 86.8 cycles
0822                  ; (using 87 cycles is also OK)
0822                  ; The serial port is wired up like this:
0822                  ;   TX  out port 3, bit 0
0822                  ;   RX  in port 3, bit 0
0822                  ;   RTS out port 3, bit 1
0822                  ;   CTS in port 3, bit 1
0822              
0822                  ; - Write one byte to the serial port. May block execution if hardware flow
0822                  ;   control blocks transmission.
0822                  ; param L0 ... value to write
0822                  ; local L1 ... counter)
0822                  AREA CODE 100
0822              
0822              TRANSMIT:
0822                  ; wait until partner can accept data (CTS is low)
0822 a3 b1 03 c5      LOAD R1 PORT3
0826 b0 02            SET R0 $02
0828 51               AND R1 R0
0829 84 22            BGE R1 R0 TRANSMIT
082b              
082b                  ; counter for bits, including stop bit
082b b1 09            SET R1 9
082d a5 b0 01 d1      STORE R1 L1
0831              
0831                  ; start bit
0831 b1 fe            SET R1 $FE
0833 b0 03            SET R0 .PORT3
0835 a3               DP ^PORT3
0836 d1               ST R1 R0                                 ;       0
0837                  ; do delay
0837 b1 01            SET R1 1                                 ; 2     2
0839 b0 17            SET R0 23                                ; 2     4
083b              TRANSMIT_DELAYLOOP1:
083b 24               SUB R0 R1                            ; 1
083c 81 3b            BGE R0 R1 TRANSMIT_DELAYLOOP1        ; 2
083e                                                           ; 23*3 73 = -14
083e              TRANSMIT_WRITELOOP:
083e                  ; send next bit
083e b0 00            SET R0 .L0                               ; 2   -12
0840 a5               DP ^L0                                   ; 1   -11
0841 c1               LD R1 R0                                 ; 2    -9
0842 b0 fe            SET R0 $FE                               ; 2    -7
0844 61               OR R1 R0                                 ; 1    -6
0845 b0 03            SET R0 .PORT3                            ; 2    -4
0847 a3               DP ^PORT3                                ; 1    -3
0848 d1               ST R1 R0                                 ; 3     0
0849                  ; do delay
0849 b1 01            SET R1 1                                 ; 2     2
084b b0 0c            SET R0 12                                ; 2     4
084d              TRANSMIT_DELAYLOOP2:
084d 24               SUB R0 R1                            ; 1
084e 81 4d            BGE R0 R1 TRANSMIT_DELAYLOOP2        ; 2
0850                                                           ; 12*3 44 = -43
0850                  ; shift bits to right, filling with 1s
0850 b0 00            SET R0 .L0                               ; 2   -43
0852 a5               DP ^L0                                   ; 1   -42
0853 c1               LD R1 R0                                 ; 2   -40
0854 b0 02            SET R0 2                                 ; 2   -38
0856 41               DIV R1 R0                                ; 1   -37
0857 b0 80            SET R0 $80                               ; 2   -35
0859 61               OR R1 R0                                 ; 1   -34
085a b0 00            SET R0 .L0                               ; 2   -32
085c a5               DP ^L0                                   ; 1   -31
085d d1               ST R1 R0                                 ; 2   -29
085e                  ; decrement counter and loop
085e b0 01            SET R0 .L1                               ; 2   -27
0860 a5               DP ^L1                                   ; 1   -26
0861 c1               LD R1 R0                                 ; 2   -25
0862 b0 01            SET R0 1                                 ; 2   -23
0864 21               SUB R1 R0                                ; 1   -22
0865 b0 01            SET R0 .L1                               ; 2   -21
0867 a5               DP ^L1                                   ; 1   -20
0868 d1               ST R1 R0                                 ; 2   -18
0869 b0 01            SET R0 1                                 ; 2   -16
086b 84 3e            BGE R1 R0 TRANSMIT_WRITELOOP             ; 2   -14
086d              
086d 9e               JMP R2 R3
086e              
086e              
086e                  ; - Read one byte of data from the serial port. This procedure blocks until
086e                  ; one byte is available. It will use the hardware flow control signals to make
086e                  ; the partner only send data if the program is actively listening.
086e                  ; Because the partner may continue sending a few more bytes even after
086e                  ; RTS is de-asserted, a small buffer (8 bytes) is kept .
086e                  ; return R1 .. the byte received
086e                  ; local L0,L1 return address
086e              
086e                  AREA DATA 10
0208              RECEIVE_BUFFERFILL:
0208 00               BYTE 0              ; number of bytes still available from previous receives
0209              RECEIVE_BUFFERUSED:
0209 00               BYTE 0              ; how many bytes of the buffer area alread consumed
020a              RECEIVE_BUFFER:
020a 00 00 00 00      BYTE 0 0 0 0 0 0 0 0  ; the buffer itself
020e 00 00 00 00 
0212              
0212                  AREA CODE 150
0900              RECEIVE:
0900                  ; keep return address
0900 a5 b0 00 d2      STORE R2 R3 L0
0904 b0 01 d3    
0907              
0907                  ; check if there is still some data in the buffer
0907 a5 b2 08 ca      LOAD R2 RECEIVE_BUFFERFILL
090b a5 b3 09 cf      LOAD R3 RECEIVE_BUFFERUSED
090f 8e 29            BGE R3 R2 RECEIVE_FETCHMORE
0911              
0911                  ; fetch one byte from the buffer and return to caller
0911              RECEIVE_USEFROMBUFFER:
0911 a5 b3 09 cf      LOAD R3 RECEIVE_BUFFERUSED
0915 b0 0a            SET R0 .RECEIVE_BUFFER
0917 1c               ADD R0 R3
0918 a5               DP ^RECEIVE_BUFFER
0919 c1               LD R1 R0
091a b0 01            SET R0 1
091c 13               ADD R3 R0
091d a5 b0 09 d3      STORE R3 RECEIVE_BUFFERUSED
0921 a5 b2 00 ca      LOAD R2 R3 L0
0925 b3 01 cf    
0928 9e               JMP R2 R3
0929              
0929              RECEIVE_FETCHMORE:
0929                  ; reset buffer
0929 75               ZERO R1
092a a5 b0 08 d1      STORE R1 RECEIVE_BUFFERFILL
092e a5 b0 09 d1      STORE R1 RECEIVE_BUFFERUSED
0932                  ; prepeare for quick access
0932 b3 01            SET R3 $01  ; mask for bit 0
0934                  ; signal to partner that data can be accepted (RTS low)
0934 a3               DP ^PORT3
0935 b1 03            SET R1 .PORT3
0937 b0 fd            SET R0 $FD
0939 d4               ST  R0 R1
093a              
093a                  ; wait until detecting the start bit (low signal on RX)
093a              RECEIVE_WAITFORSTART:
093a c4               LD R0 R1                                    ;     -43
093b 5c               AND R0 R3                                   ; 1   -42
093c 83 3a            BGE R0 R3 RECEIVE_WAITFORSTART              ; 2   -40
093e                  ; immediately turn off the RTS line,
093e                  ; so partner will not send another byte
093e b0 ff            SET R0 $FF                                  ; 2   -38
0940 d4               ST R0 R1                                    ; 3   -35
0941              
0941                  ; do delay to get into the middle
0941                  ; of the first data bit
0941 b1 01            SET R1 1                                    ; 2   -33
0943 b0 24            SET R0 36                                   ; 2   -31
0945              RECEIVE_DELAYLOOP1:
0945 24               SUB R0 R1                               ; 1
0946 81 45            BGE R0 R1 RECEIVE_DELAYLOOP1:           ; 2
0948                                                              ; 36*3 77
0948 50               NOP                                         ; 1    78
0949              RECEIVE_READBITS:
0949 7a               ZERO R2  ; accumulated bits                 ; 1    79
094a b3 08            SET R3 8 ; bit counter                      ; 2    81
094c              RECEIVE_BITLOOP:
094c                  ; read input bit and move to bit 7 of R1
094c b0 03            SET R0 .PORT3                               ; 2    83
094e a3               DP ^PORT3                                   ; 1    84
094f              
094f c1               LD R1 R0                                    ; 3    87 = 0
0950 b0 01            SET R0 1                                    ; 2     2
0952 51               AND R1 R0                                   ; 1     3
0953 b0 80            SET R0 128                                  ; 2     5
0955 31               MUL R1 R0                                   ; 1     6
0956                  ; shift R2 and insert new bit
0956 b0 02            SET R0 2                                    ; 2     8
0958 42               DIV R2 R0                                   ; 1     9
0959 66               OR R2 R1                                    ; 1    10
095a                  ; do delay to get to the next bit
095a                  ; (data or stop bit)
095a b1 01            SET R1 1                                    ; 2    12
095c b0 15            SET R0 21                                   ; 2    14
095e              RECEIVE_DELAYLOOP2:
095e 24               SUB R0 R1                               ; 1
095f 81 5e            BGE R0 R1 RECEIVE_DELAYLOOP2:           ; 2
0961                                                              ; 21*3 77
0961                  ; continue for necessary amount of bits
0961 b0 01            SET R0 1                                    ; 2    79
0963 23               SUB R3 R0                                   ; 1    80
0964 8c 4c            BGE R3 R0 RECEIVE_BITLOOP                   ; 2    82
0966              
0966                  ; add received data to buffer
0966 a5 b3 08 cf      LOAD R3 RECEIVE_BUFFERFILL                  ; 5
096a b0 0a            SET R0 .RECEIVE_BUFFER                      ; 2
096c 1c               ADD R0 R3                                   ; 1
096d a5               DP ^RECEIVE_BUFFER                          ; 1
096e d2               ST R2 R0                                    ; 2
096f b0 01            SET R0 1                                    ; 2
0971 13               ADD R3 R0                                   ; 1
0972 a5 b0 08 d3      STORE R3 RECEIVE_BUFFERFILL                 ; 5
0976              
0976                  ; prevent buffer from overflow
0976 b0 08            SET R0 8                                    ; 2
0978 8c 11            BGE R3 R0 RECEIVE_USEFROMBUFFER             ; 2
097a              
097a                  ; wait some additional time to see if the partner
097a                  ; sends more data. synchronize to start bit
097a b3 01            SET R3 $01 ; mask for bit 0, (just a 1)     ; 2
097c b2 32            SET R2 50  ; maximum time to wait           ; 2
097e a3               DP ^PORT3                                   ; 1
097f b1 03            SET R1 .PORT3                               ; 2
0981              RECEIVE_WAITFORRESTART:
0981 2e               SUB R2 R3                                   ; 1
0982 8e 11            BLE R2 R3 RECEIVE_USEFROMBUFFER ; stop      ; 2
0984 c4               LD R0 R1                                    ; 3
0985 5c               AND R0 R3                                   ; 1   -44
0986 83 81            BGE R0 R3 RECEIVE_WAITFORRESTART            ; 2   -42
0988              
0988                  ; new start bit found.
0988                  ; wait until reaching middle of data
0988 b1 01            SET R1 1                                    ; 2   -40
098a b0 26            SET R0 38                                   ; 2   -38
098c              RECEIVE_DELAYLOOP3:
098c 24               SUB R0 R1                               ; 1
098d 81 8c            BGE R0 R1 RECEIVE_DELAYLOOP3:           ; 2   3*38 76
098f              
098f 80 49            BRA RECEIVE_READBITS                        ; 2    78
0991              
0991              
0991              ; ------------------------- Various tools ----------------------------------
0991              
0991                 ; - Delay for given number of milliseconds
0991                  ; param L0 ... milliseconds
0991                  AREA CODE 100
086e              
086e              DELAY:
086e                  ; keep return address
086e a5 b0 02 d2      STORE R2 R3 L2
0872 b0 03 d3    
0875              DELAY_OUTER:
0875                  ; simple loop to delay 1 millisecond
0875 b0 01            SET R0 1
0877 b1 00            SET R1 0
0879 b2 0c            SET R2 12
087b              DELAY_INNER:
087b 21               SUB R1 R0
087c 84 7b            BGE R1 R0 DELAY_INNER
087e 22               SUB R2 R0
087f 88 7b            BGE R2 R0 DELAY_INNER
0881                  ; subtract 1 millisecond
0881 a5 b1 00 c5      LOAD R1 L0
0885 b0 01            SET R0 1
0887 21               SUB R1 R0
0888 a5 b0 00 d1      STORE R1 L0
088c b0 01            SET R0 1
088e 84 75            BGE R1 R0 DELAY_OUTER
0890                  ; retrieve return address
0890 a5 b2 02 ca      LOAD R2 R3 L2
0894 b3 03 cf    
0897 9e               JMP R2 R3
0898              
0898              
0898              ; ------------ Bootstrapping ---------------------------------------------------------
0898                  ; store a duplicate of the very low portion of the code to PAGE 0 also,
0898                  ; so it can be accessed by the first copy loop
0898                  ORG $0080
0080 b1 ff a3 b0      DUPLICATE CODE 128
0084 02 d1 a3 b0 
0088 03 d1 b3 02 
008c a3 b0 00 d3 
0090 7a a1 c9 ac 
0094 d9 b0 01 12 
0098 88 11 13 8c 
009c 0c b0 08 b1 
00a0 0d 94 a3 b1 
00a4 03 c5 b0 02 
00a8 51 84 22 b1 
00ac 09 a5 b0 01 
00b0 d1 b1 fe b0 
00b4 03 a3 d1 b1 
00b8 01 b0 17 24 
00bc 81 3b b0 00 
00c0 a5 c1 b0 fe 
00c4 61 b0 03 a3 
00c8 d1 b1 01 b0 
00cc 0c 24 81 4d 
00d0 b0 00 a5 c1 
00d4 b0 02 41 b0 
00d8 80 61 b0 00 
00dc a5 d1 b0 01 
00e0 a5 c1 b0 01 
00e4 21 b0 01 a5 
00e8 d1 b0 01 84 
00ec 3e 9e a5 b0 
00f0 02 d2 b0 03 
00f4 d3 b0 01 b1 
00f8 00 b2 0c 21 
00fc 84 7b 22 88 
0100              ; ----------- various routines for unsigned 16-bit mathematics ----------------------
0100              
0100              ;  -- Add two 16 bit values
0100              ;  input: L0 low byte of first operand
0100              ;         L1 high byte of first operand
0100              ;         L2 low byte of second operand
0100              ;         L3 high byte of second operand
0100              ;  output: L0 low byte of sum
0100              ;          L1 high byte of sum
0100                  AREA CODE 40
0898              ADD16:
0898 a5 b0 04 d2      STORE R2 R3 L4
089c b0 05 d3    
089f              
089f a5 b2 00 ca      LOAD R2 R3 L0
08a3 b3 01 cf    
08a6 a5 b0 02 c0      LOAD R0 R1 L2
08aa b1 03 c5    
08ad 17               ADD R3 R1
08ae 12               ADD R2 R0
08af 08               GT R0 R2  ; overflow detection
08b0 13               ADD R3 R0 ; carry
08b1 a5 b0 00 d2      STORE R2 R3 L0
08b5 b0 01 d3    
08b8              
08b8 a5 b2 04 ca      LOAD R2 R3 L4
08bc b3 05 cf    
08bf 9e               JMP R2 R3
08c0              
08c0              ;  -- Subtract two 16 bit values
08c0              ;  input: L0 low byte of first operand
08c0              ;         L1 high byte of first operand
08c0              ;         L2 low byte of second operand
08c0              ;         L3 high byte of second operand
08c0              ;  output: L0 low byte of sum
08c0              ;          L1 high byte of sum
08c0                  AREA CODE 50
08c0              SUB16:
08c0 a5 b0 04 d2      STORE R2 R3 L4
08c4 b0 05 d3    
08c7              
08c7 a5 b2 00 ca      LOAD R2 R3 L0
08cb b3 01 cf    
08ce a5 b0 02 c0      LOAD R0 R1 L2
08d2 b1 03 c5    
08d5 27               SUB R3 R1
08d6 22               SUB R2 R0
08d7 59 69            COPY R1 R2
08d9 a5 b0 00 c0      LOAD R0 L0
08dd 01               GT R1 R0  ; underflow detection
08de 27               SUB R3 R1 ; borrow
08df a5 b0 00 d2      STORE R2 R3 L0
08e3 b0 01 d3    
08e6              
08e6 a5 b2 04 ca      LOAD R2 R3 L4
08ea b3 05 cf    
08ed 9e               JMP R2 R3
08ee              
08ee              ; -- Multiply a 16-bit value with a 8-bit value
08ee              ;  input: L0 low byte of first operand
08ee              ;         L1 high byte of first operand
08ee              ;         L2 second operand
08ee              ;  output: L0 low byte of result
08ee              ;          L1 high byte of operand
08ee              ;  The most diffcult part of the computation is to compute the high byte
08ee              ;  of the product of the low bytes. This is done by splitting the numbers to
08ee              ;  4-bit digits and manually do the multiplication matrix.
08ee              ;  L0 = A B    L2 = C D
08ee                  AREA CODE 100
0991              MUL168:
0991 a5 b0 04 d2      STORE R2 R3 L4
0995 b0 05 d3    
0998              
0998                  ; Compute the high byte of the low-byte multiplications
0998 a5 b3 00 cf      LOAD R3 L0
099c b0 0f            SET R0 15
099e 53               AND R3 R0   ; B
099f a5 b2 02 ca      LOAD R2 L2
09a3 52               AND R2 R0   ; D
09a4 3b               MUL R3 R2   ; B*D
09a5 b0 10            SET R0 16
09a7 43               DIV R3 R0   ; overflow to digit 1
09a8              
09a8 a5 b2 00 ca      LOAD R2 L0
09ac b0 0f            SET R0 15
09ae 52               AND R2 R0   ; B
09af a5 b1 02 c5      LOAD R1 L2
09b3 b0 10            SET R0 16
09b5 41               DIV R1 R0   ; C
09b6 36               MUL R2 R1   ; B*C
09b7 1b               ADD R3 R2   ; collect digit 1&2
09b8              
09b8 a5 b2 00 ca      LOAD R2 L0
09bc b0 10            SET R0 16
09be 42               DIV R2 R0   ; A
09bf a5 b1 02 c5      LOAD R1 L2
09c3 b0 0f            SET R0 15
09c5 51               AND R1 R0   ; D
09c6 36               MUL R2 R1   ; A*D
09c7 1b               ADD R3 R2   ; collect digit 1&2
09c8 0e               GT R2 R3    ; overflow to digit 3
09c9 b0 10            SET R0 16
09cb 43               DIV R3 R0   ; start with columns 2&3
09cc 32               MUL R2 R0   ; adjust overflow to fit digit 2&3
09cd 1b               ADD R3 R2   ; join from the overflow
09ce              
09ce a5 b2 00 ca      LOAD R2 L0
09d2 b0 10            SET R0 16
09d4 42               DIV R2 R0   ; A
09d5 a5 b1 02 c5      LOAD R1 L2
09d9 41               DIV R1 R0   ; C
09da 36               MUL R2 R1   ; A*C
09db 1b               ADD R3 R2   ; complete column 2&3
09dc                  ; we have the high byte of low byte multiplication now in R3
09dc              
09dc                  ; complete the high byte of the result
09dc a5 b1 01 c5      LOAD R1 L1
09e0 a5 b2 02 ca      LOAD R2 L2
09e4 36               MUL R2 R1
09e5 1b               ADD R3 R2
09e6 a5 b0 01 d3      STORE R3 L1
09ea              
09ea                  ; compute low byte of result (easy)
09ea a5 b1 00 c5      LOAD R1 L0
09ee a5 b2 02 ca      LOAD R2 L2
09f2 39               MUL R1 R2
09f3 a5 b0 00 d1      STORE R1 L0
09f7              
09f7 a5 b2 04 ca      LOAD R2 R3 L4
09fb b3 05 cf    
09fe 9e               JMP R2 R3
09ff              
09ff              
09ff                  AREA DATA 3
0212              MUL16_RET:
0212 00 00            BYTE 0 0
0214              MUL16_VX:
0214 00               BYTE 0
0215              
0215              ; -- Multiply two 16-bit values
0215              ;  input: L0 low byte of first operand
0215              ;         L1 high byte of first operand
0215              ;         L2 low byte of second operand
0215              ;         L3 high byte of second operand
0215              ;  output: L0 low byte of result
0215              ;          L1 high byte of operand
0215                  AREA CODE 100
0a00              MUL16:
0a00 a5 b0 12 d2      STORE R2 R3 MUL16_RET
0a04 b0 13 d3    
0a07              
0a07 a5 b2 00 ca      LOAD R2 L0      ; calculate first row of multiplication matrix
0a0b a5 b3 03 cf      LOAD R3 L3
0a0f 3e               MUL R2 R3
0a10 a5 b0 14 d2      STORE R2 MUL16_VX
0a14              
0a14 b2 1d b3 0a      CALL MUL168     ; calculate second row of multiplication matrix
0a18 b0 91 b1 09 
0a1c 94          
0a1d              
0a1d a5 b2 14 ca      LOAD R2 MUL16_VX  ; join rows
0a21 a5 b3 01 cf      LOAD R3 L1
0a25 1b               ADD R3 R2
0a26 a5 b0 01 d3      STORE R3 L1
0a2a              
0a2a a5 b2 12 ca      LOAD R2 R3 MUL16_RET
0a2e b3 13 cf    
0a31 9e               JMP R2 R3
0a32              
0a32              
0a32              
0a32              ; -- Divide a 16-bit vaulue by an 8-bit value
0a32              ;  input: L0 low byte of first operand
0a32              ;         L1 high byte of first operand
0a32              ;         L2 second operand (divisor)
0a32              ;  output: L0 low byte of result
0a32              ;          L1 high byte of operand
0a32                  AREA CODE 200
0a32              DIV168:
0a32                  ; check if first operand <= 255
0a32 a5 b1 01 c5      LOAD R1 L1
0a36 b0 01            SET R0 1
0a38 84 48            BGE R1 R0 DIV168_FULL
0a3a                  ; use built-in operation
0a3a a5 b1 00 c5      LOAD R1 L0
0a3e a5 b0 02 c0      LOAD R0 L2
0a42 41               DIV R1 R0
0a43 a5 b0 00 d1      STORE R1 L0
0a47 9e               JMP R2 R3
0a48              
0a48                  ; full operation
0a48              DIV168_FULL:
0a48 a5 b0 04 d2      STORE R2 R3 L4
0a4c b0 05 d3    
0a4f              
0a4f                  ; high byte of the result can be created with built in operation
0a4f a5 b1 01 c5      LOAD R1 L1
0a53 a5 b2 02 ca      LOAD R2 L2
0a57 57 67            COPY R3 R1
0a59 49               DIV R1 R2
0a5a a5 b0 01 d1      STORE R1 L1
0a5e 39               MUL R1 R2
0a5f 27               SUB R3 R1    ; remainder
0a60              
0a60                  ; process the low byte bit by bit doing a full division algorithm
0a60                  ;  R3 ... current remainder
0a60                  ;  R2 ... active bit counter (running from $80 to $01)
0a60                  ;  R1 ... low result byte
0a60 b2 80            SET R2 $80
0a62 75               ZERO R1
0a63              DIV168_LOOP:
0a63                  ; decide if the remainder can be shifted without overflow
0a63 b0 80            SET R0 128
0a65 8c 7e            BGE R3 R0 DIV168_BIGREMAINDER
0a67                  ; shift remainder and bring in next bit
0a67 b0 02            SET R0 2
0a69 33               MUL R3 R0
0a6a a5 b0 00 c0      LOAD R0 L0
0a6e 58               AND R0 R2
0a6f 82 73            BGE R0 R2 DIV168_BRING_1
0a71 80 76            BRA DIV168_CHECKFIT
0a73                  ; get next bit from second operand
0a73              DIV168_BRING_1:
0a73 b0 01            SET R0 1
0a75 63               OR R3 R0
0a76                  ; test if divisor fits into extended remainder
0a76              DIV168_CHECKFIT:
0a76 a5 b0 02 c0      LOAD R0 L2
0a7a 8c 8d            BGE R3 R0 DIV168_DOSUBTRACT:
0a7c 80 93            BRA DIV168_ENDOFLOOP
0a7e                  ; in case the remainder is >=128 the divisor will
0a7e                  ; surely fit after shifting, so just shift and add bit
0a7e                  ; and no need to do any fit test
0a7e              DIV168_BIGREMAINDER:
0a7e b0 02            SET R0 2
0a80 33               MUL R3 R0
0a81 a5 b0 00 c0      LOAD R0 L0
0a85 58               AND R0 R2
0a86 82 8a            BGE R0 R2 DIV168_BRING_1_NOCHECK:
0a88 80 8d            BRA DIV168_DOSUBTRACT
0a8a              DIV168_BRING_1_NOCHECK:
0a8a b0 01            SET R0 1
0a8c 63               OR R3 R0
0a8d                  ; if divisor fits, subtract it and use a 1 digit in result
0a8d              DIV168_DOSUBTRACT:
0a8d a5 b0 02 c0      LOAD R0 L2
0a91 23               SUB R3 R0
0a92 69               OR R1 R2
0a93                  ; progress bit counter
0a93              DIV168_ENDOFLOOP:
0a93 b0 02            SET R0 2
0a95 42               DIV R2 R0
0a96 b0 01            SET R0 1
0a98 88 63            BGE R2 R0 DIV168_LOOP
0a9a              
0a9a                  ; store result and return
0a9a a5 b0 00 d1      STORE R1 L0
0a9e a5 b2 04 ca      LOAD R2 R3 L4
0aa2 b3 05 cf    
0aa5 9e               JMP R2 R3
0aa6              
0aa6              ; ------ various print routines (strings, numbers, etc) --------------------------
0aa6              
0aa6                  ; Write a single character to the standard output (normally serial port)
0aa6                  AREA CODE 10
08ee              PRINT:
08ee b0 22 b1 08      GOTO TRANSMIT
08f2 94          
08f3              
08f3              
08f3              
08f3                  AREA DATA 4
0215              PRINTSTRING_RETADDR:
0215 00 00            BYTE 0 0
0217              PRINTSTRING_PTR:
0217 00 00            BYTE 0 0
0219              
0219                  ; --- Write a null-terminated string to the standard output
0219                  ; param L0 ... low byte of pointer to string
0219                  ; param L1 ... high byte of pointer to string
0219                  AREA CODE 40
0aa6              PRINTSTRING:
0aa6 a5 b0 15 d2      STORE R2 R3 PRINTSTRING_RETADDR
0aaa b0 16 d3    
0aad              
0aad a5 b2 00 ca      LOAD R2 R3 L0
0ab1 b3 01 cf    
0ab4 a5 b0 17 d2      STORE R2 R3 PRINTSTRING_PTR
0ab8 b0 18 d3    
0abb              PRINTSTRING_LOOP:
0abb a5 b2 17 ca      LOAD R2 R3 PRINTSTRING_PTR
0abf b3 18 cf    
0ac2 ac               DP R3
0ac3 c9               LD R1 R2
0ac4 70               ZERO R0
0ac5 81 ea            BLE R1 R0 PRINTSTRING_DONE
0ac7              
0ac7 a5 b0 00 d1      STORE R1 L0
0acb b2 d4 b3 0a      CALL TRANSMIT
0acf b0 22 b1 08 
0ad3 94          
0ad4              
0ad4 a5 b2 17 ca      LOAD R2 R3 PRINTSTRING_PTR
0ad8 b3 18 cf    
0adb b0 01            SET R0 1
0add 12               ADD R2 R0
0ade 88 e1            BGE R2 R0 PRINTSTRING_NOOVERFLOW
0ae0 13               ADD R3 R0
0ae1              PRINTSTRING_NOOVERFLOW:
0ae1 a5 b0 17 d2      STORE R2 R3 PRINTSTRING_PTR
0ae5 b0 18 d3    
0ae8 80 bb            BRA PRINTSTRING_LOOP
0aea              
0aea              PRINTSTRING_DONE:
0aea a5 b2 15 ca      LOAD R2 R3 PRINTSTRING_RETADDR
0aee b3 16 cf    
0af1 9e               JMP R2 R3
0af2              
0af2                  AREA CODE 20
0b00                  ; ---- Write a single number (0 - 15) as a hex digit
0b00                  ; param L0: the number to write
0b00              PRINTDIGIT:
0b00 a5 b1 00 c5      LOAD R1 L0
0b04 b0 09            SET R0 9
0b06 81 0b            BLE R1 R0 PRINTDIGIT_ISDECIMAL
0b08 b0 07            SET R0 7   ; gap between '9' and 'A' in ASCII
0b0a 11               ADD R1 R0
0b0b              PRINTDIGIT_ISDECIMAL:
0b0b b0 30            SET R0 48  ; ASCII '0'
0b0d 11               ADD R1 R0
0b0e a5 b0 00 d1      STORE R1 L0
0b12 b0 ee b1 08      GOTO PRINT  ; - tail call
0b16 94          
0b17              
0b17                  AREA CODE 30
0b17              PRINTNEWLINE_CRLF:
0b17 0d 0a 00         BYTE 13 10 0
0b1a                  ; --- Write a line break (ascii 13 10) to the standard output
0b1a              PRINTNEWLINE:
0b1a b1 17            SET R1 .PRINTNEWLINE_CRLF
0b1c a5 b0 00 d1      STORE R1 L0
0b20 b1 0b            SET R1 ^PRINTNEWLINE_CRLF
0b22 a5 b0 01 d1      STORE R1 L1
0b26 b0 a6 b1 0a      GOTO PRINTSTRING
0b2a 94          
0b2b              
0b2b                  AREA CODE 10
08f3                  ; --- Write a single blank space to the standard output
08f3              PRINTSPACE:
08f3 b1 20            SET R1 32  ; ' '
08f5 a5 b0 00 d1      STORE R1 L0
08f9 b0 ee b1 08      GOTO PRINT
08fd 94          
08fe              
08fe              
08fe                  AREA CODE 10
0af2                  ; --- Write decimal representation of an 8-bit unsigned number to the standard output
0af2                  ; param L0 ... the number
0af2              PRINT8:
0af2 75               ZERO R1
0af3 a5 b0 01 d1      STORE R1 L1
0af7 b0 b0 b1 0b      GOTO PRINTHEX  ; tail call
0afb 94          
0afc              
0afc              
0afc                  AREA DATA 4
0219              PRINT16_RETADDR:
0219 00 00            BYTE 0 0
021b              PRINT16_VALUE:
021b 00 00            BYTE 0 0
021d              PRINT16_BUFFER:
021d 00 00 00 00      BYTE 0 0 0 0 0
0221 00          
0222              PRINT16_ENDMARKER:
0222 00               BYTE 0
0223              PRINT16_INDEX:
0223 00               BYTE 0
0224              
0224                  AREA CODE 100
0b2b                  ; --- Write decimal representation of an 8-bit unsigned number to the standard output
0b2b                  ; param L0 ... low byte of the number
0b2b                  ; param L1 ... high byte of the number
0b2b              PRINT16:
0b2b a5 b0 19 d2      STORE R2 R3 PRINT16_RETADDR
0b2f b0 1a d3    
0b32              
0b32                  ; set up counters
0b32 a5 b2 00 ca      LOAD R2 R3 L0
0b36 b3 01 cf    
0b39 a5 b0 1b d2      STORE R2 R3 PRINT16_VALUE
0b3d b0 1c d3    
0b40 b1 22            SET R1 .PRINT16_ENDMARKER
0b42 a5 b0 23 d1      STORE R1 PRINT16_INDEX
0b46              
0b46                  ; convert the number from back to front
0b46              PRINT16_LOOP:
0b46                  ; divide by 10
0b46 a5 b2 1b ca      LOAD R2 R3 PRINT16_VALUE
0b4a b3 1c cf    
0b4d a5 b0 00 d2      STORE R2 R3 L0
0b51 b0 01 d3    
0b54 b2 0a            SET R2 10
0b56 a5 b0 02 d2      STORE R2 L2
0b5a b2 63 b3 0b      CALL DIV168
0b5e b0 32 b1 0a 
0b62 94          
0b63 a5 b2 00 ca      LOAD R2 R3 L0  ; fetch result to registers
0b67 b3 01 cf    
0b6a                  ; determine the remainder
0b6a a5 b1 1b c5      LOAD R1 PRINT16_VALUE
0b6e b0 0a            SET R0 10
0b70 38               MUL R0 R2  ; multiply result back by 10
0b71 21               SUB R1 R0  ; subtract from dividend get remainder
0b72                  ; keep division result for next iteration
0b72 a5 b0 1b d2      STORE R2 R3 PRINT16_VALUE
0b76 b0 1c d3    
0b79                  ; write current digit to buffer backwards
0b79 a5 b2 23 ca      LOAD R2 PRINT16_INDEX
0b7d b0 01            SET R0 1
0b7f 22               SUB R2 R0
0b80 a5 b0 23 d2      STORE R2 PRINT16_INDEX
0b84 a5               DP ^PRINT16_BUFFER
0b85 b0 30            SET R0 48  ; get ASCII value of digit
0b87 11               ADD R1 R0
0b88 d9               ST R1 R2
0b89                  ; continue while value is not 0
0b89 a5 b2 1b ca      LOAD R2 R3 PRINT16_VALUE
0b8d b3 1c cf    
0b90 b1 01            SET R1 1
0b92 89 46            BGE R2 R1 PRINT16_LOOP
0b94 8d 46            BGE R3 R1 PRINT16_LOOP
0b96              
0b96                  ; print the content of the buffer
0b96 a5 b1 23 c5      LOAD R1 PRINT16_INDEX
0b9a a5 b0 00 d1      STORE R1 L0
0b9e b1 02            SET R1 ^PRINT16_BUFFER
0ba0 a5 b0 01 d1      STORE R1 L1
0ba4              
0ba4 a5 b2 19 ca      LOAD R2 R3 PRINT16_RETADDR
0ba8 b3 1a cf    
0bab b0 a6 b1 0a      GOTO PRINTSTRING  ; tail call
0baf 94          
0bb0              
0bb0              
0bb0                  AREA DATA 4
0224              PRINTHEX_RETADDR:
0224 00 00            BYTE 0 0
0226              PRINTHEX_LOW:
0226 00               BYTE 0
0227              PRINTHEX_HIGH:
0227 00               BYTE 0
0228              
0228                  AREA CODE 50
0bb0                  ; --- Write hexadecimal representation of a 16-bit number to the standard output.
0bb0                  ; param L0 ... low byte
0bb0                  ; param L1 ... high byte
0bb0              PRINTHEX:
0bb0 a5 b0 24 d2      STORE R2 R3 PRINTHEX_RETADDR
0bb4 b0 25 d3    
0bb7 a5 b2 00 ca      LOAD R2 R3 L0
0bbb b3 01 cf    
0bbe a5 b0 26 d2      STORE R2 R3 PRINTHEX_LOW
0bc2 b0 27 d3    
0bc5              
0bc5 b0 10            SET R0 16
0bc7 43               DIV R3 R0
0bc8 a5 b0 00 d3      STORE R3 L0
0bcc b2 d5 b3 0b      CALL PRINTDIGIT
0bd0 b0 00 b1 0b 
0bd4 94          
0bd5              
0bd5 a5 b3 27 cf      LOAD R3 PRINTHEX_HIGH
0bd9 b0 0f            SET R0 $0f
0bdb 53               AND R3 R0
0bdc a5 b0 00 d3      STORE R3 L0
0be0 b2 e9 b3 0b      CALL PRINTDIGIT
0be4 b0 00 b1 0b 
0be8 94          
0be9              
0be9 a5 b3 26 cf      LOAD R3 PRINTHEX_LOW
0bed b0 10            SET R0 16
0bef 43               DIV R3 R0
0bf0 a5 b0 00 d3      STORE R3 L0
0bf4 b2 fd b3 0b      CALL PRINTDIGIT
0bf8 b0 00 b1 0b 
0bfc 94          
0bfd              
0bfd a5 b3 26 cf      LOAD R3 PRINTHEX_LOW
0c01 b0 0f            SET R0 $0f
0c03 53               AND R3 R0
0c04 a5 b0 00 d3      STORE R3 L0
0c08              
0c08 a5 b2 24 ca      LOAD R2 R3 PRINTHEX_RETADDR
0c0c b3 25 cf    
0c0f b0 00 b1 0b      GOTO PRINTDIGIT   ; tail call
0c13 94          
0c14              
0c14                  AREA DATA 3
0228 00 00        P:  BYTE 0 0
022a 00           TMP: BYTE 0
022b 00 00        CHECKSUM: BYTE 0 0
022d              
022d                  ; Test program that implements the sieve of erathostenes prime number calculator.
022d                  ; This uses the RAM at external memory bank 8 to memorize the found non-primes.
022d                  AREA CODE 256
0d00 50 72 69 6d  TITLE: BYTE 'P' 'r' 'i' 'm' 'e' 's' 32 0
0d04 65 73 20 00 
0d08              MAIN:
0d08                  ; set up external RAM bank to use in program
0d08 b1 08            SET R1 8
0d0a a3 b0 01 d1      STORE R1 XDATABANK
0d0e b2 17 b3 0d      CALL PRINTNEWLINE
0d12 b0 1a b1 0b 
0d16 94          
0d17              
0d17              BIGCOMPUTATION:
0d17              
0d17                  ; startup message
0d17 b2 00            SET R2 .TITLE
0d19 b3 0d            SET R3 ^TITLE
0d1b a5 b0 00 d2      STORE R2 R3 L0
0d1f b0 01 d3    
0d22 b2 2b b3 0d      CALL PRINTSTRING
0d26 b0 a6 b1 0a 
0d2a 94          
0d2b              
0d2b                  ; clear the prime number flags
0d2b 7f               ZERO R3
0d2c 7a               ZERO R2
0d2d b1 01            SET R1 1
0d2f              CLEARLOOP:
0d2f a3 b0 00 d3      STORE R3 XDATAPAGE
0d33 a1               DP 0
0d34 70               ZERO R0
0d35              CLEARLOOP2:
0d35 d8               ST R0 R2
0d36 16               ADD R2 R1
0d37 89 35            BGE R2 R1 CLEARLOOP2
0d39 17               ADD R3 R1
0d3a 8d 2f            BGE R3 R1 CLEARLOOP
0d3c              
0d3c b0 00 b1 0e      GOTO COMPUTE2
0d40 94          
0d41              
0d41                  AREA CODE 256
0e00              COMPUTE2:
0e00                  ; loop from 2 to 255
0e00 b2 02            SET R2 2
0e02 b3 00            SET R3 0
0e04 a5 b0 28 d2      STORE R2 R3 P
0e08 b0 29 d3    
0e0b              PRIMELOOP:
0e0b                  ; check if this numbers was marked. If not, this is a prime
0e0b a5 b2 28 ca      LOAD R2 R3 P
0e0f b3 29 cf    
0e12 a3 b0 00 d3      STORE R3 XDATAPAGE
0e16 a1               DP 0
0e17 c9               LD R1 R2
0e18 b0 01            SET R0 1
0e1a 84 6d            BGE R1 R0 FINDNEXT
0e1c              ;    ; print the prime number
0e1c              ;    LOAD R2 R3 P
0e1c              ;    STORE R2 R3 L0
0e1c              ;    CALL PRINT16
0e1c              ;    CALL PRINTSPACE
0e1c                  ; loop to mark all multiplies
0e1c a5 b2 28 ca      LOAD R2 R3 P
0e20 b3 29 cf    
0e23 a5 b0 00 d2      STORE R2 R3 L0    ; use L0/L1 as loop counter
0e27 b0 01 d3    
0e2a              MARKLOOP:
0e2a                  ; go to next multiple
0e2a a5 b2 00 ca      LOAD R2 R3 L0
0e2e b3 01 cf    
0e31 a5 b0 2a d3      STORE R3 TMP
0e35 a5 b2 28 ca      LOAD R2 R3 P
0e39 b3 29 cf    
0e3c a5 b0 02 d2      STORE R2 R3 L2
0e40 b0 03 d3    
0e43 b2 4c b3 0e      CALL ADD16
0e47 b0 98 b1 08 
0e4b 94          
0e4c                  ; test if overflowing
0e4c a5 b2 00 ca      LOAD R2 R3 L0
0e50 b3 01 cf    
0e53 a5 b1 2a c5      LOAD R1 TMP
0e57 0d               GT R1 R3  ; if previous is bigger, this was overflow
0e58 b0 01            SET R0 1
0e5a 84 6d            BGE R1 R0 FINDNEXT
0e5c                  ; mark the multiple
0e5c a5 b2 00 ca      LOAD R2 R3 L0
0e60 b3 01 cf    
0e63 a3 b0 00 d3      STORE R3 XDATAPAGE
0e67 a1               DP 0
0e68 b0 01            SET R0 1
0e6a d8               ST R0 R2
0e6b 80 2a            BRA MARKLOOP
0e6d              FINDNEXT:
0e6d                  ; increment the counter until reaching >255
0e6d a5 b2 28 ca      LOAD R2 P
0e71 b0 01            SET R0 1
0e73 12               ADD R2 R0
0e74 a5 b0 28 d2      STORE R2 P
0e78 b0 01            SET R0 1
0e7a 88 0b            BGE R2 R0 PRIMELOOP
0e7c b0 00 b1 0f      GOTO PRINTRESULT
0e80 94          
0e81              
0e81                  AREA CODE 256
0f00                  ; after running the sieve, print/sum all primes
0f00              PRINTRESULT:
0f00                  ; clear the checksum
0f00 7a               ZERO R2
0f01 a5 b0 2b d2      STORE R2 R2 CHECKSUM
0f05 b0 2c d2    
0f08                  ; start from 2
0f08 b2 02            SET R2 2
0f0a 7f               ZERO R3
0f0b a5 b0 28 d2      STORE R2 R3 P
0f0f b0 29 d3    
0f12              PRINTLOOP:
0f12                  ; check if this numbers was marked. If not, this is a prime
0f12 a5 b2 28 ca      LOAD R2 R3 P
0f16 b3 29 cf    
0f19 a3 b0 00 d3      STORE R3 XDATAPAGE
0f1d a1               DP 0
0f1e c9               LD R1 R2
0f1f b0 01            SET R0 1
0f21 84 56            BGE R1 R0 NOTPRIME
0f23                  ; add the prime number to checksum
0f23 a5 b2 2b ca      LOAD R2 R3 CHECKSUM
0f27 b3 2c cf    
0f2a a5 b0 00 d2      STORE R2 R3 L0
0f2e b0 01 d3    
0f31 a5 b2 28 ca      LOAD R2 R3 P
0f35 b3 29 cf    
0f38 a5 b0 02 d2      STORE R2 R3 L2
0f3c b0 03 d3    
0f3f b2 48 b3 0f      CALL ADD16
0f43 b0 98 b1 08 
0f47 94          
0f48 a5 b2 00 ca      LOAD R2 R3 L0
0f4c b3 01 cf    
0f4f a5 b0 2b d2      STORE R2 R3 CHECKSUM
0f53 b0 2c d3    
0f56              ;   LOAD R2 R3 P
0f56              ;   STORE R2 R3 L0
0f56              ;   CALL PRINT16
0f56              ;   CALL PRINTSPACE
0f56              
0f56              NOTPRIME:
0f56                  ; increment P until overflow
0f56 a5 b2 28 ca      LOAD R2 R3 P
0f5a b3 29 cf    
0f5d b1 01            SET R1 1
0f5f 16               ADD R2 R1
0f60 a5 b0 28 d2      STORE R2 P
0f64 89 12            BGE R2 R1 PRINTLOOP
0f66 17               ADD R3 R1
0f67 a5 b0 28 d2      STORE R2 R3 P
0f6b b0 29 d3    
0f6e 8d 12            BGE R3 R1 PRINTLOOP
0f70              
0f70              ENDRESULT:
0f70 a5 b2 2b ca      LOAD R2 R3 CHECKSUM
0f74 b3 2c cf    
0f77 a5 b0 00 d2      STORE R2 R3 L0
0f7b b0 01 d3    
0f7e b2 87 b3 0f      CALL PRINT16
0f82 b0 2b b1 0b 
0f86 94          
0f87 b2 90 b3 0f      CALL PRINTNEWLINE
0f8b b0 1a b1 0b 
0f8f 94          
0f90 b0 17 b1 0d      GOTO BIGCOMPUTATION
0f94 94          
